import { Tile } from './tile';
import { Cell, createCell, isCollapsed } from './cell';
import { Direction, directions, opposite } from './direction';

export type TileDefinition<Edge, Type> = {
	edges: [up: Edge, right: Edge, down: Edge, left: Edge],
	type: Type,
	weight: number,
	exceptions?: Partial<Record<Direction, Type[]>>
}

type WfcDefinition<TileType, EdgeType> = {
	options: {
		saveInterval?: number,
		baseWeight: number
	},
	tiles: TileDefinition<EdgeType, TileType>[],
	compareEdge(a: EdgeType, b: EdgeType): boolean,
}

class OutOfOptionsError extends Error {
	constructor(message?: string) {
		super(message ?? "No options left");
	}
}

export default class WFC<TileType, EdgeType> {
	/** The percentage of cells that need to be collapsed before the map is saved defined in the options (0.025 = 2.5%)  */
	private saveIntervalPercentage = this.definition.options.saveInterval || 0.02;
	/** The tiles used in the algorithm  */
	private tiles: Tile<TileType, EdgeType>[] = [];
	/** A 2D array of cells  */
	private grid: Cell[][];
	/** The final map generated by the algorithm (2D array of tile indexes)  */
	private finalMap: number[][] = [];
	/** Queue of coordinates, in buckets ordered by Shannon entropy, ascending. */
	private priorityQueue: { x: number; y: number; }[][];
	/** The previous state of the algorithm (Used for rollback)  */
	private previousStates: { priorityQueue: any; collapsedCells: any; grid: any; };
	/** The number of cells that have been collapsed  */
	private collapsedCells: number;
	/** The total number of cells in the map  */
	private totalCells: number;
	/** The percentage of cells that need to be collapsed before the map is saved used by the algorithm  */
	private saveInterval: number;
	/** A boolean that determines if the the state should be saved on the next iteration  */
	private saveNext: boolean;
	/** The number of cells that need to be collapsed before the map is saved  */
	private nextSave: number;
	/** The cells that have been changed since the last save (Used for rollback)  */
	private changedCells: { x: number; y: number; }[];
	/** The width of the map  */
	private width: number;
	/** The width of the priority queue (Set to the max number of options a tile has in one direction)  */
	private pqLength: number;

	private rollbackCount = 0;

	constructor(private definition: WfcDefinition<TileType, EdgeType>) {
		for (const [index, def] of definition.tiles.entries()) {
			this.tiles.push(new Tile(def.edges, index, def.type, def.exceptions, def.weight || definition.options.baseWeight, 0));
		}
		// Analyze the tiles edges to get the possible options for each tile
		for (const tile of this.tiles) {
			tile.analyze(this.tiles, definition.compareEdge);
		}
		this.pqLength = this.getQueueLength();
	}

	/**
	 * @description: Collapse a new grid using the WFC algorithm and return the final map
	 * @param { number } dimensions - The width and height of the map
	 * @returns { number[][] } The final map
	 */
	public collapse(dimensions: number): number[][] {
		this.resetState(dimensions);
		while (this.collapsedCells < this.totalCells) {
			if (this.collapsedCells === 0) {
				const cell = this.getRandomCell();
				cell.options = Array(this.tiles.length).fill(0, 0, -1).map((_, i) => i);
				this.collapseAndFinishCell(cell);
			} else {
				try {
					while (this.collapsedCells < this.totalCells) {
						const cell = this.getNextCell();
						cell.inQueue = false;
						if (cell.options.length > 1) {
							this.updateSelf(cell);
						}
						if (cell.options.length === 0) {
							throw new OutOfOptionsError();
						}
						if (this.collapsedCells >= this.nextSave) {
							this.nextSave += this.saveInterval;
							this.saveNext = true;
						}
						if (this.saveNext === true && cell.options.length > 2) {
							this.saveNow();
						}
						this.collapseAndFinishCell(cell);
						this.collapsedCells++;
					}
				} catch (e) {
					if (e instanceof OutOfOptionsError) {
						this.rollback();
						continue;
					}
				}
			}
			this.collapsedCells++;
		}
		return this.finalMap;
	}

	private collapseAndFinishCell(cell: Cell): void {
		this.collapseCell(cell);
		this.onCellChanged(cell);
		this.finalMap[cell.x][cell.y] = cell.index;
		this.updateNeighbors(cell);
	}

	/** Rollback the algorithm to the saved state */
	private rollback() {
		if (this.rollbackCount++ > 100) throw new Error("Rollback limit exceeded");
		for (const { x, y } of this.changedCells) {
			this.grid[x][y] = JSON.parse(JSON.stringify(this.previousStates.grid[x][y]));
		}
		this.collapsedCells = this.previousStates.collapsedCells;
		this.priorityQueue = JSON.parse(JSON.stringify(this.previousStates.priorityQueue));
		this.changedCells = [];
	}

	private onCellChanged(cell: Cell) {
		this.changedCells.push({ x: cell.x, y: cell.y });
	}
	
	private saveNow(): void {
		this.previousStates.collapsedCells = this.collapsedCells;
		this.previousStates.priorityQueue = JSON.parse(JSON.stringify(this.priorityQueue));
		for (const { x, y } of this.changedCells) {
			this.previousStates.grid[x][y] = JSON.parse(JSON.stringify(this.grid[x][y]));
		}
		this.changedCells = [];
		this.saveNext = false;
	}

	/** Collapse a cell down to a single option */
	private collapseCell(cell: Cell) {
		if (!isCollapsed(cell)) {
			const optionWeights = cell.options.map(option => this.tiles[option].weight);
			cell.index = this.weightedRandom(cell.options, optionWeights);
			cell.options = [cell.index];
		}
	}

	/** Get a random cell from the grid */
	private getRandomCell(): Cell {
		let x = Math.floor(Math.random() * this.width);
		let y = Math.floor(Math.random() * this.width);
		return this.grid[x][y];
	}

	/** Get a random next cells coordinates from the priority queue and remove it from the queue */
	private getNextCell(): Cell {
		for (const slot of this.priorityQueue) {
			if (slot.length > 0) {
				const randomIndex = Math.floor(Math.random() * slot.length);
				const { x, y } = slot.splice(randomIndex, 1)[0];
				return this.grid[x][y];
			}
		}
		throw new OutOfOptionsError("Priority queue is empty");
	}

	/** Get a random index from the options using the weights */
	private weightedRandom(options: number[], weights: number[]): number {
		const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
		const randomWeight = Math.random() * totalWeight;
		let weightSum = 0;
		for (let i = 0; i < options.length; i++) {
			weightSum += weights[i];
			if (randomWeight <= weightSum) {
				return options[i];
			}
		}
		return options[options.length - 1];
	}

	/** Update the neighbors of the cell and push them to the priority queue */
	private updateNeighbors(cell: Cell) {
		let neighbors = this.getNeighbors(cell);
		for (let i = 0; i < 4; i++) {
			const neighbor = neighbors[i];
			if (!isCollapsed(neighbor)) {
				if (neighbor.inQueue) {
					const queueSlot = this.getQueueSlotFor(neighbor);
					queueSlot.splice(queueSlot.findIndex(c => c.x === neighbor.x && c.y === neighbor.y), 1);
				}
				if (!neighbor.options) {
					neighbor.options = [...this.tiles[cell.index].directions[i]];
				}
				this.updateSelf(neighbor);
				this.onCellChanged(neighbor);
				if (neighbor.options.length === 0) {
					throw new OutOfOptionsError();
				}
				this.getQueueSlotFor(neighbor).push({ x: neighbor.x, y: neighbor.y });
				neighbor.inQueue = true;
			}
		}
	}


	/** Update the cell based on its neighbors' options */
	private updateSelf(cell: Cell) {
		let neighbors = this.getNeighbors(cell);
		for (const dir of directions) {
			if (neighbors[dir].options) {
				const validOptions = neighbors[dir].options.flatMap(
					option => this.tiles[option].directions[opposite(dir)]
				);
				cell.options = cell.options.filter(x => validOptions.includes(x))
			}
		}
	}

	/** Get the neighbors of the cell in the order up, right, down, left wrapping around the grid */
	private getNeighbors(cell: Cell): Record<Direction, Cell> {
		const directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];

		return directions.map(([dx, dy]) => {
			let neighborX = (cell.x + dx + this.width) % this.width;
			let neighborY = (cell.y + dy + this.width) % this.width;
			return this.grid[neighborX][neighborY];
		}) as any;
	}

	/** Set all the variables to their initial values */
	private resetState(newWidth: number) {
		this.grid = Array.from(Array(newWidth), (_, x) => Array.from(Array(newWidth), (_, y) => createCell(x, y)));
		this.finalMap = Array.from(Array(newWidth), () => new Array(newWidth).fill(null));
		this.priorityQueue = Array.from(Array(this.pqLength), () => []);
		this.collapsedCells = 0;
		this.saveNext = false;
		this.nextSave = 0;
		this.changedCells = [];
		this.width = newWidth;
		this.totalCells = newWidth * newWidth;
		this.saveInterval = Math.floor(this.totalCells * this.saveIntervalPercentage);
		this.previousStates = { grid: JSON.parse(JSON.stringify(this.grid)), collapsedCells: this.collapsedCells, priorityQueue: JSON.parse(JSON.stringify(this.priorityQueue)) };
	}

	/**
	 * @description: A function to test the performance of the algorithm
	 * @param { number } dimensions - The width and height of the grid
	 * @param { number } iterations - The number of iterations to test (Start with 1 to get a baseline time then increase to get a more average time)
	 */
	public test(dimensions: number, iterations: number) {
		let totalTime = 0;
		for (let i = 0; i < iterations; i++) {
			let start = Date.now();
			this.collapse(dimensions);
			let end = Date.now();
			totalTime += (end - start);
		}
		console.log((totalTime / iterations) / 1000);
	}

	/** Calculates the width of the priority queue */
	private getQueueLength(): number {
		// for each tile check all directions and get the max number of options
		return Math.max(...this.tiles.flatMap(
			tile => Object.values(tile.directions).map(d => d.length)
		));
	}

	private getQueueSlotFor(cell: Cell) {
		return this.priorityQueue[cell.options.length - 1];
	}
}